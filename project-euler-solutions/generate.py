#!/usr/bin/env python
import os
import re
import glob
import json
import shutil
import codecs
import hashlib
import datetime
import markdown
import math
import subprocess
from clint.textui import progress, puts, indent, colored  
from jinja2 import Template

languages = {
    '.py': 'Python',
    '.rb': 'Ruby',
    '.clj': 'Clojure',
    '.c': 'C',
    '.scm': 'Scheme',
    '.go': 'Go',
    '.hs': 'Haskell',
    '.cpp': 'C++',
    '.java': "Java"
}

lexers = {
    '.py': 'python',
    '.rb': 'ruby',
    '.clj': 'clojure',
    '.c': 'c',
    '.scm': 'scheme',
    '.go': 'go',
    '.hs': 'haskell',
    '.cpp': 'c++',
    '.java': 'java'
}

interpreters = {
    '.py': 'pypy',
    '.rb': 'ruby',
    '.clj': 'clj',
    '.c': None,
    '.scm': 'mit-scheme --quiet <',
    '.go': 'go run',
    '.hs': 'runhaskell',
    '.cpp': 'bash',
    '.java': 'bash'
}

post_template = Template('''\
---
layout: post
mathjax: true
comments: true
date: {{ problem.last_modified }}
title: [Project Euler] #{{ problem.number }} Solution
excerpt: |
    {{ problem.excerpt }}
tags:
- project euler problem {{ problem.number }} solution
- project euler problem {{ problem.number }} answer{% for solution in problem.solutions %}
- project euler problem {{ problem.number }} {{ solution.language | lower }}{% endfor %}
---
{% if problem.solved == False %}
  <div class="incorrect_banner">I haven't solved this problem yet. My attempts are below.</div>
{% endif %}
<div class="euler">
{% if problem.question or problem.answer %}
<h2>Overview</h2>
<div class="divider">&nbsp;</div>
{% if problem.question %}
<h3>Question</h3>
{{ problem.question }}
{% endif %}

{% if problem.answer %}
<style type="text/css">
h3.answer_toggle:hover {
    color: #01579F;
    text-decoration: underline;
    cursor: pointer;
}
.answer {
    display: none;
}
</style>
<script type="text/javascript">
    function toggleAnswer() {
        $('.answer').css('display', 'block');
        //$('.answer_toggle').removeClass('answer_toggle');
        $('.answer_toggle').text("answer")
    }
</script>
<h3 class="answer_toggle" onclick="toggleAnswer();">click for answer</h3>
<pre class="answer">{{ problem.answer }}</pre>
{% endif %}
{% endif %}

{% if problem.commentary %}
<h2>Commentary</h2>
<div class="divider">&nbsp;</div>
{{ problem.commentary }}
{% endif %}

<h2>Solutions</h2>
<div class="divider">&nbsp;</div>
{% for solution in problem.solutions %}
<h3>{{ solution.language }} {{ "<div class='incorrect_banner'>Incorrect</div>" if solution.correct == False}}</h3>
{{ solution }}
{% if solution.execution_time %}
{{ solution.execution_time }}
{% endif %}
{% endfor %}
</div>
''')

index_template = Template('''\
---
layout: page
title: Project Euler
group: navigation
excerpt: |
    Solutions to {{ problems | length }} Project Euler problems in Python, Ruby, Haskell, Clojure, Go, and Scheme.
tags:
---
<p style="padding-bottom: 25px; margin-bottom: 25px; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC') bottom left repeat-x;">This directory of solutions is generated by a pretty brilliant Python script by <a href="http://zacharydenton.com">Zach Denton</a>. I don't know him personally but found his site online and the credit for the process of building this page and the solution pages definitely goes to him, but all of the solutions I list are my own. I also modified the script quite a bit for my needs and re-styled things. Hopefully in the future I can rewrite it to Ruby (Do __not__ like Python) and then it'll be a lot more of my own. :) The generator script scans through the aforementioned git repository and compiles it all into the posts you see below. If you want, you can take a look at <a href="https://github.com/addamh/addamhardy.com/blob/master/source/project-euler-solutions/generate.py">the source code of this script</a>.</p>
<table class="grid">
    <tbody>
    <tr>
      <td style="background-color: #dcdcdc; text-align: right; font-weight: bold;" colspan=25>Completed {{correct | length}} out of {{405}} -- {{(((correct | length)/405)*100)|round(2, 'floor') }}%</td>
    </tr>
    {% for i in range(rows) %}
      <tr>
      {% set start = ((i+1)+(24*i)) %}
      {% set end = (start+25) %}
      {% for item in a[start:end] %}
      
      {% if (item | int) in attempted %}
        {% if (item | int) in correct %}
          {% set flag = "solved" %}
        {% else %}
          {% set flag = "attempted" %}
        {% endif %}
      {% else %}
        {% set flag = "" %}
      {% endif %}
      
        <td class="{{flag}}" style=
        "width:12px;height:12px;vertical-align:middle;">
          <a target="_blank" href="http://projecteuler.net/problem={{item}}">
          <div style="font-size:70%;text-align:center;cursor:pointer;" class="info">
            {{item}}
          </div></a>
        </td>
      {% endfor %}
      </tr>
    {% endfor %}
    
    </tbody>
</table>

{% for problem in problems %}
<div style="margin-bottom: 25px;">
  <h2 class="problem_block {{"attempted" if problem.solved == False}}"><a href="{{ problem.number }}/">#{{ problem.number }}</a></h2>
  <ul class="languages">
  {% for language in problem.languages %}
  <li><code>{{ language }}</code></li>
  {% endfor %}
  </ul>
  <p class="meta">
  Updated: <time datetime="{{ problem.last_modified }}" pubdate data-updated="true">{{ problem.last_modified.strftime("%B %d, %Y") }}</time>.
  </p>
</div>
{% endfor %}
''')

cache_dir = os.path.join(os.path.dirname(__file__), ".cache")

class Problem(object):
    def __init__(self, path):
        self.path = path
        self.dirname = os.path.split(self.path)[-1]
        self.solutions = []
        self.correct = False

        for solution in os.listdir(self.path):
            basename, filetype = os.path.splitext(solution)
            if filetype in languages.keys():
                solution = Solution(os.path.join(self.path, solution))
                if solution.test():
                    self.solutions.append(solution)

        if not self.solutions: return

        self.solutions.sort(key = lambda s: s.language)

        # set last_modified to the latest modification date of any of the solutions
        self.last_modified = sorted([solution.last_modified for solution in self.solutions])[-1]

        # strip zeros from directory
        self.number = int(re.sub('^0+', '', self.dirname))

        # generate a filename for the post
        self.filename = '%s/index.html' % (self.number)

        # grab the question from question.markdown
        try:
            question_file = glob.glob(os.path.join(self.path, 'question.*'))[0]
            basename, extension = os.path.splitext(question_file)
            if extension == '.markdown':
                self.question = markdown.markdown(codecs.open(question_file, 'r', 'utf-8').read())
            else:
                self.question = codecs.open(question_file, 'r', 'utf-8').read()
        except Exception as e:
            self.question = ''

        # grab the answer from answer.markdown
        try:
            answer_file = glob.glob(os.path.join(self.path, 'answer.*'))[0]
            basename, extension = os.path.splitext(answer_file)
            if extension == '.markdown':
                self.answer = markdown.markdown(codecs.open(answer_file, 'r', 'utf-8').read())
            else:
                self.answer = codecs.open(answer_file, 'r', 'utf-8').read()
        except Exception as e:
            self.answer = ''

        # grab the commentary from commentary.markdown
        try:
            commentary_file = glob.glob(os.path.join(self.path, 'commentary.*'))[0]
            basename, extension = os.path.splitext(commentary_file)
            if extension == '.markdown':
                self.commentary = markdown.markdown(codecs.open(commentary_file, 'r', 'utf-8').read())
            else:
                self.commentary = codecs.open(commentary_file, 'r', 'utf-8').read()
        except:
            self.commentary = ''

    @property
    def title(self):
        return "Problem {number} Solution".format(number=self.number)

    @property
    def link(self):
        return '/project-euler-solutions/' + os.path.dirname(self.filename) + '/'

    @property
    def languages(self):
        return sorted(list(set(sln.language for sln in self.solutions)))
        
    @property
    def solved(self):
        flags = [s.correct for s in self.solutions]
        if True in flags:
          return True
        else:
          return False

    def save(self, directory):
        self.content = post_template.render(problem=self).encode('utf-8')
        problem_dir = os.path.dirname(os.path.join(directory, self.filename))
        if os.path.isdir(problem_dir):
            shutil.rmtree(problem_dir)
        os.mkdir(problem_dir)
        open(os.path.join(directory, self.filename), 'w').write(self.content)

    def __unicode__(self):
        return self.content

    def __str__(self):
        return self.__unicode__()

    @property
    def excerpt(self):
        if len(self.languages) == 1 and len(self.solutions) > 1:
            output = "This page presents solutions to Project Euler Problem %s in %s." % (self.number, self.languages[0])
        elif len(self.languages) == 1:
            return "This page presents a %s solution to Project Euler Problem %s." % (self.languages[0], self.number)
        else:
            output = "This page presents solutions to Project Euler Problem %s in " % self.number
            if len(self.languages) == 2:
                return output + "%s and %s." % (self.languages[0], self.languages[1])
            else:
                return output + "%s and %s." % (', '.join(self.languages[:-1]), self.languages[-1])

class Solution(object):
    def __init__(self, path):
        basename, filetype = os.path.splitext(path)
        self.language = languages[filetype]
        self.interpreter = interpreters[filetype]
        self.lexer = lexers[filetype]
        self.path = path
        self.correct = False
        self.basename = os.path.basename(self.path)
        self.answer = open(os.path.join(os.path.dirname(self.path), 'answer.txt')).read().strip()
        self.github_link = 'https://github.com/addamh/euler/blob/master' + self.path.replace(os.path.expanduser('~/dev/euler'), '')
        self.raw_link = 'https://raw.github.com/addamh/euler/master' + self.path.replace(os.path.expanduser('~/dev/euler'), '')
        self.content = codecs.open(self.path, 'r', 'utf-8').read()
        self.last_modified = datetime.date.fromtimestamp(os.path.getmtime(self.path))
        self.sha1 = hashlib.sha1(self.content).hexdigest()
        self.execution_time = ''

    def __unicode__(self):
        self.content = re.sub(r'\/\/&.*', r'', self.content)
        #output = '{%% codeblock %s %s download %%}\n' % (self.basename, self.raw_link)
        #output = '{%% highlight %s %%}\n' % self.interpreter
        output = '``` %s %s %s download\n' % (self.lexer, self.basename, self.raw_link)
        output += self.content 
        output += '\n```\n'
        #output += '{% endhighlight %}'
        #output += '{% endcodeblock %}'
        return output 

    def __str__(self):
        return self.__unicode__()

    def test(self):
        output = None
        try:
            output = json.loads(open(os.path.join(cache_dir, self.sha1)).read())
        except:
            if self.interpreter:
                output = subprocess.Popen('bash -c "time %s %s 2>/dev/null"' % (self.interpreter, self.path), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
                with open(os.path.join(cache_dir, self.sha1), 'w') as cache:
                    cache.write(json.dumps(output))
        finally:
            if output:
                self.execution_time = '''\
{%% highlight console %%}
$ time %s %s
%s
{%% endhighlight %%}
''' % (self.interpreter, self.basename, output[1].strip())
                if output[0].strip() == self.answer:
                  self.correct = True
                  return True
                else: 
                  print colored.red("Incorrect Answer: [%s] %s" % (self.interpreter, self.path))
                  return True
            print colored.red("failed: %s %s" % (self.interpreter, self.path))
            if os.path.exists(os.path.join(cache_dir, self.sha1)):
                os.remove(os.path.join(cache_dir, self.sha1))
            return False

def generate_posts(problems, output_dir):
    '''rebuild all posts.'''
    for problem in problems:
        problem.save(output_dir)
        
def generate_index(problems, output):
    problems = sorted(problems, key = lambda problem: problem.number)
    content = index_template.render(
        problems=problems,
        a = range(405+1),
        rows = int((405+1)/25)+1,
        correct = [o.number for o in problems if o.solved == True],
        attempted = [o.number for o in problems]
    ).encode('utf-8')
    open(output, 'w').write(content)

def is_problem(path):
    directory = os.path.split(path)[-1]
    if not (os.path.isdir(path) and directory.isdigit()):
        return False

    for solution in os.listdir(path):
        basename, filetype = os.path.splitext(solution)
        if filetype in languages.keys():
            return True

    return False

def main():
    print "\n==========================================="
    print colored.green("Starting Eueler Solution Generator")
    print "===========================================\n"
    euler_dir = os.path.expanduser('~/dev/euler')
    posts_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)))
    index = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'index.html')

    problems = []
    print colored.yellow("Progress:")
    for directory in progress.bar(os.listdir(euler_dir)):
        path = os.path.join(euler_dir, directory)
        if is_problem(path):
            problems.append(Problem(path))

    problems = filter(lambda p: p.solutions, problems)
    problems.sort(key = lambda p: p.number)

    print "\n==========================================="
    print colored.green("Processed %d problem(s)" % len(problems))
    print "==========================================="
    for i, problem in enumerate(problems):
        if i > 0:
            problem.previous = problems[i-1]
        if i < len(problems) - 1:
            problem.next = problems[i+1]

    generate_posts(problems, posts_dir)
    generate_index(problems, index)

if __name__ == "__main__":
    main()
